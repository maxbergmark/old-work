function [F, Fp, Fpp, Fppp, y] = FSC_JF(m, Theta, y, T0, T1, T2, T3)% [u0, u1, u2, w0, w1, w2] = FSC_JF(m, Theta, y, T0, T1, T2, T3)%   returns the velocity profile u0 and its derivatives u1, u2 at %   the points y. T0... are the polynomial coefficient matrices and%   m is the pressure gradient%   initialize variables    epsilon = 1.d-9 ;    hmp1 = (m + 1)/2 ;    n  = length(y) ;    f  = zeros(n,1) ; f0 = zeros(n,1) ; f1 = zeros(n,1) ; f2 = zeros(n,1) ;    b  = zeros(n,1) ; x  = ones(n,1) ;    A  = zeros(3) ;%   construct valid initial conditions      b(3) = 1 ;    A(1,:) = T0(1,1:3) ;    A(2,:) = T1(1,1:3) ;    A(3,:) = T1(n,1:3) ;    f(1:3) = A \ b(1:3) ;    A  = zeros(n) ;%   iterate    k = 0 ;    while ( max(abs(x)) > epsilon )&( k < 200 )%   while max(abs(x)) > epsilon        k = k + 1 ;%   accumulate f, df, d^2f for later use        f0 = T0*f ; FF0 = diag(f0)*ones(n) ;        f1 = T1*f ; FF1 = diag(f1)*ones(n) ;        f2 = T2*f ; FF2 = diag(f2)*ones(n) ;%   construct matrix, right-hand-side              b  = -(T3*f + hmp1*(f0.*f2) - m*(f1.*f1) + m) ;        A  = T3 + hmp1*( FF0.*T2 + FF2.*T0 ) - 2*m*FF1.*T1 ;%   boundary conditions on the correction        b(1) = 0 ;        b(2) = 0 ;        b(n) = 0 ;        A(1,:) = T0(1,:) ;        A(2,:) = T1(1,:) ;        A(n,:) = T1(n,:) ;%   solve for the correction, update representation of f        x  = A \ b ;        f  = f + x ;    end%   accumulate answer: u = df, du = d^2f, d^2u = d^3f    ff = T0 * f ; % aug. 2011 JF    u0 = T1 * f ;    u1 = T2 * f ;    u2 = T3 * f ;        F = ff ;    Fp = u0 ;    Fpp = u1 ;    Fppp = u2 ;    %   iterate for g    f0 = T0 * f ; FF0 = diag(f0)*ones(n) ;    k = 0 ; x = ones(n,1) ; b  = zeros(n,1) ; g = zeros(n,1) ; A = zeros(2);%   initial conditions    b(2) = 1;    A(1,:) = T0(1,1:2);    A(2,:) = T0(n,1:2);    g(1:2) = A \ b(1:2);        while ( max(abs(x)) > epsilon )&( k < 100 )        k = k + 1 ;        b = -(T2 + hmp1*FF0.*T1)*g;        A = T2 + hmp1*FF0.*T1 ;        b(1) = 0;        b(n) = 0;        A(1,:) = T0(1,:) ;        A(n,:) = T0(n,:) ;        x = A \ b ;        g = g + x ;    end%   accumulate answer for w component and derivs    w0 = T0 * g;    w1 = T1 * g;    w2 = T2 * g;%   project results onto external streamline relative x- and y-planes    [u0, w0] = Shift(Theta, u0, w0);    [u1, w1] = Shift(Theta, u1, w1);    [u2, w2] = Shift(Theta, u2, w2);	